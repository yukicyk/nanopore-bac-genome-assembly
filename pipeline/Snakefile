# ================================================================= #
#               NANOPORE BACTERIAL GENOME PIPELINE                  #
#                      MASTER SNAKEFILE (v2.1)                      #
# ================================================================= #
import pandas as pd

# --- 1. CONFIGURATION ---
configfile: "config/config.yaml"

try:
    SAMPLES_DF = pd.read_csv(config["resolved_sample_sheet"], sep="\t").set_index("sample_id", drop=False)
except FileNotFoundError:
    raise SystemExit(f"ERROR: The resolved sample sheet '{config['resolved_sample_sheet']}' was not found. "
                     "Please run your 'fetch_or_prompt.py' script first.")

SAMPLES = list(SAMPLES_DF.index)


# --- 2. LOGIC: DETERMINE FINAL OUTPUTS PER SAMPLE ---

def get_final_assemblies(wildcards):
    """
    Inspects the sample sheet for a given sample and returns the path
    to its expected final assembly file.
    """
    sample_info = SAMPLES_DF.loc[wildcards.sample]
    has_ont = pd.notna(sample_info.get("ont_reads")) and sample_info.get("ont_reads")
    has_illumina = pd.notna(sample_info.get("illumina_r1")) and sample_info.get("illumina_r1")

    if has_ont and has_illumina:
        return f"results/{wildcards.sample}/polish/pilon/assembly.fasta"
    elif has_ont:
        return f"results/{wildcards.sample}/polish/medaka/consensus.fasta"
    elif has_illumina:
        return f"results/{wildcards.sample}/assembly/spades/scaffolds.fasta"
    else:
        return []

# --- NEW HELPER FUNCTION ---
def get_final_annotation(wildcards):
    """
    Inspects the config and returns the path to the expected final
    annotation file based on the chosen annotator.
    """
    # Default to 'bakta' if the option is missing in the config
    annotator = config.get("annotator", "bakta").lower()
    if annotator == "prokka":
        return f"results/{wildcards.sample}/annotation/prokka/{wildcards.sample}.gff"
    else: # Default to bakta
        return f"results/{wildcards.sample}/annotation/bakta/{wildcards.sample}.gbff"


# --- 3. AGGREGATION: DEFINE ALL FINAL DELIVERABLES ---
rule all:
    input:
        # Updated to use lambda functions to generate the dynamic file lists.
        # Snakemake executes these functions to get the list of inputs.

        # 1. Get all final assemblies by calling our helper for each sample.
        lambda wc: [get_final_assemblies(type('Wildcards', (), {'sample': s})()) for s in SAMPLES],

        # 2. Get all final annotations by calling our helper for each sample.
        lambda wc: [get_final_annotation(type('Wildcards', (), {'sample': s})()) for s in SAMPLES],

        # 3. For static paths, expand still works perfectly.
        expand("results/{sample}/evaluation/quast/report.html", sample=SAMPLES),

        # 4. Include single files directly.
        "results/multiqc_report.html"
    message:
        "Pipeline finished successfully. All requested outputs have been generated."

# --- 4. MODULARIZATION: INCLUDE RULE FILES ---
include: "rules/qc.smk"
include: "rules/assembly.smk"
include: "rules/polish.smk"
include: "rules/evaluation.smk"
include: "rules/annotation.smk"
include: "rules/report.smk"