# ================================================================= #
#               NANOPORE BACTERIAL GENOME PIPELINE                  #
#                      MASTER SNAKEFILE (v2.5)                      #
# ================================================================= #
import pandas as pd

# --- 1. CONFIGURATION AND SAMPLE LOADING ---
configfile: "config/config.yaml"

try:
    SAMPLES_DF = pd.read_csv(config["resolved_sample_sheet"], sep="\t").set_index("sample_id", drop=False)
except FileNotFoundError:
    raise SystemExit(f"ERROR: The resolved sample sheet '{config['resolved_sample_sheet']}' was not found. "
                     "Please run your 'fetch_or_prompt.py' script first.")

SAMPLES = list(SAMPLES_DF.index)

# --- 2. FILTERED SAMPLE LISTS FOR TARGETING ---
def has_data(series):
    """Helper function to check for a valid, non-empty string path."""
    return pd.notna(series) & (series != '')

ONT_SAMPLES = SAMPLES_DF[has_data(SAMPLES_DF["ont_reads"])].index.tolist()
ILLUMINA_SAMPLES = SAMPLES_DF[has_data(SAMPLES_DF["illumina_r1"])].index.tolist()
ASSEMBLY_SAMPLES = sorted(list(set(ONT_SAMPLES + ILLUMINA_SAMPLES)))


# --- 3. GLOBAL HELPER FUNCTIONS ---
# All helper functions are defined here, BEFORE the include statements.

def get_final_assemblies(wildcards):
    """
    Inspects the sample sheet for a given sample and returns the path
    to its expected final assembly file based on the data present.
    """
    sample_info = SAMPLES_DF.loc[wildcards.sample]
    has_ont = wildcards.sample in ONT_SAMPLES
    has_illumina = wildcards.sample in ILLUMINA_SAMPLES

    if has_ont and has_illumina:
        return f"results/{wildcards.sample}/polish/pilon/assembly.fasta"
    elif has_ont:
        return f"results/{wildcards.sample}/polish/medaka/consensus.fasta"
    elif has_illumina:
        return f"results/{wildcards.sample}/assembly/spades/scaffolds.fasta"
    else:
        raise ValueError(f"Sample {wildcards.sample} has no reads defined.")

def get_final_annotation(wildcards):
    """
    Inspects the config and returns the path to the expected final
    annotation file based on the chosen annotator.
    """
    annotator = config.get("annotation", {}).get("tool", "bakta").lower()
    if annotator == "prokka":
        return f"results/{wildcards.sample}/annotation/prokka/{wildcards.sample}.gff"
    else: # Default to bakta
        return f"results/{wildcards.sample}/annotation/bakta/{wildcards.sample}.gbff"


# --- 4. AGGREGATION: BUILD THE LIST OF ALL FINAL DELIVERABLES ---
# This list constitutes the final output of the entire pipeline.
FINAL_FILES = []

# CORRECTED LOGIC: Use a list comprehension to call the helper functions for each sample.
# This is the correct way to generate dynamic file paths. We create a simple
# object that mimics Snakemake's wildcards object for the helper functions to use.
class MockWildcards:
    def __init__(self, sample):
        self.sample = sample

FINAL_FILES.extend([get_final_assemblies(MockWildcards(s)) for s in ASSEMBLY_SAMPLES])
FINAL_FILES.extend([get_final_annotation(MockWildcards(s)) for s in ASSEMBLY_SAMPLES])

# Use expand() for rules that have a simple, non-conditional output path.
FINAL_FILES.extend(expand("results/{sample}/evaluation/quast/report.html", sample=ASSEMBLY_SAMPLES))
FINAL_FILES.append("results/multiqc_report.html")


# --- 5. MASTER RULE: REQUEST ALL TARGETS ---
rule all:
    input:
        FINAL_FILES
    default_target: True
    message:
        "Pipeline finished successfully. All requested outputs have been generated."


# --- 6. MODULARIZATION: INCLUDE RULE FILES ---
# Now that all helpers and targets are defined, we can safely include the rules.
include: "rules/qc.smk"
include: "rules/assembly.smk"
include: "rules/polish.smk"
include: "rules/evaluation.smk"
include: "rules/annotation.smk"
include: "rules/report.smk"